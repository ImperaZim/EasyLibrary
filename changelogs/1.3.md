# 1.3.0

Released #st September 2024

**For PocketMine-MP 5.18.1**

1.3.0 is a major feature update to EasyLibrary, including support for PocketMine-MP 5.18.1 plugins, bringing a large list of features and improvements over the previous version.

It is **not** compatible with plugins written for version 1.2.0 or lower, and plugins may require code changes to work with it.

**As this changelog is quite large, its accuracy and completeness cannot be guaranteed. Make sure you're looking at the [latest revision](https://github.com/ImperaZim/EasyLibrary/blob/development/changelogs/1.3.md), as it may be amended after relatest**

## Core
- Added a new `/genplugin` command that makes it easier to create plugins based on EasyLibrary as it generates a plugin with a base structure from PluginToolKit.

## Gameplay
- **Avoid Suffocation Fixed:** You will no longer clip through the ground when teleporting to some worlds.

## Components 
### General 
- In general, the components have had some changes where new components and subcomponents have been added.

### `imperazim\components\network`
The components **Query.php** and **ServerInfo.php** were been temporarily discontinued as it does not work efficiently on localhost.

### `imperazim\components\plugin`
#### Highlights 
- Starting from version 1.3, you no longer need to explicitly define the `setPlugin(Plugin $plugin)` method in the `init()` function of your component. The frameworkâ€™s initializer now automatically assigns the plugin instance to the component, making the code more streamlined.
```php
    // For example, previously you would have to define the plugin like this:
    public static function init(PluginToolkit $plugin): array {
      self::setPlugin($plugin);
      // Your Code...
      return [];
    }
```
    
```php
    // Now it is no longer necessary!
    public static function init(PluginToolkit $plugin): array {
      // Your Code...
      return [];
    }
```
- As of version 1.3, this is no longer required. You can now access the plugin directly using `YourComponent::getPlugin()` without needing to manually assign it within the `init()` method.
- In the previous version, it was only possible to register textures using the **PluginResourcePackTrait** trait and passing a texture directory, now it is also possible to register textures passing a CDN using the **PluginCdnResourcePackTrait** trait. See below how to use it:
```php
  use imperazim\components\plugin\PluginToolkit;
  use imperazim\components\plugin\traits\PluginToolkitTrait;
  use imperazim\components\plugin\traits\PluginCdnResourcePackTrait;

  /**
  * Class YourClass
  */
  final class YourClass extends PluginToolkit {
    use PluginToolkitTrait;
    use PluginCdnResourcePackTrait;

    /**
    * Called when the plugin is enabled.
    */
    protected function onEnable(): void {
      self::setInstance(\$this);
      \$this->saveRecursiveResources();
      \$this->registerCdnTextures("cdn.yourlink.com", "textures");
    }
  }
```

### `imperazim\components\hud`
- **ScoreBoard Component** Moved from `imperazim\components\hud` to `imperazim\components\hud\scoreboard`.

### `imperazim\components\hud\scoreboard`
#### Highlights 
- Added `ScoreBoard` class in `imperazim\components\hud\scoreboard` namespace.
- Added `ScoreLine` class in `imperazim\components\hud\scoreboard` namespace.
- Added `ScoreBoardManager` class in `imperazim\components\hud\scoreboard` namespace.

#### Changes 
- **`ScoreBoard` Class**:
  - Moved from `imperazim\components\hud` to `imperazim\components\hud\scoreboard`.
  - Updated class to extend `SetDisplayObjectivePacket` and include methods for managing scoreboard lines.
  - Added methods for setting and getting lines, and managing display settings.
- **`ScoreLine` Class**:
  - Introduced a new class extending `ScorePacketEntry`.
  - Added validation for score range and methods to set score and message.

- **`ScoreBoardManager` Class**:
  - Added methods to send, remove, and update scoreboards for players. 
  - Handles operations for clearing lines and updating displays.

#### Usage 
- **Creating and Setting a ScoreBoard:**
  ```php
  use imperazim\components\hud\scoreboard\ScoreBoard;
  use pocketmine\player\Player;

  $player = /* Get your player instance */;
  $scoreBoard = new ScoreBoard("ObjectiveName");
  $scoreBoard->setDisplayName("Display Name");

  ScoreBoardManager::sendToPlayer($player, $scoreBoard);
  ```

- **Adding and Updating Lines:**
  ```php
  use imperazim\components\hud\scoreboard\ScoreLine;
  
  $scoreLine = new ScoreLine(1, "Line 1");
  $scoreBoard->setLine($scoreLine);

  // Update lines
  ScoreBoardManager::updateToPlayer($player);
  ```

- **Clearing Lines:**
  ```php
  ScoreBoardManager::clearLine($player, 1); // Clears the line with score 1
  ```

- **Removing a ScoreBoard:**
  ```php
  ScoreBoardManager::removeFromPlayer($player);
  ```

### `imperazim\components\utils`
New classes have been added to the `Utils` component. See below which methods exist in each of the classes:
- **`ArrayUtils`**
  - ``select(string $query, array $data): array;``
  - ``insert(string $query, array &$data): array;``
  - ``update(string $query, array &$data): array;``
  - ``delete(string $query, array &$data): array;``
  - ``query(string $query, array &$data): array|string;``
  - ``merge(array $array1, array $array2): array;``
  - ``pluck(array $array, string $key): array;``
  - ``flatten(array $array): array;``
  - ``groupBy(array $array, string $key): array;``
- **`HttpUtils`**
  - ``sendGetRequest(string $url, array $params = []): array;``
  - ``sendPostRequest(string $url, array $data = []): array;``
  - ``parseQueryParams(string $url): array;``
- **`ValidationUtils`**
  - ``isEmail(string $email): bool;``
  - ``isPhoneNumber(string $phone): bool;``
  - ``isUrl(string $url): bool;``
  - ``isInteger(string $value): bool;``
- **`ResourcePack`**
  - ``registerPack(string $zipFile): void;``

### `imperazim\components\trigger`
**The Trigger class** represents a system of task-based triggers, where a condition is checked and if that condition is met, an action is executed. It is used to manage dynamic tasks in the system, triggering scripts when a certain condition is met.
- **`PerPlayerTrigger:`** To create a trigger that performs an action for each player when a specific condition is met, see below:
   ```php 
    use imperazim\components\trigger\PerPlayerTrigger;
  
    // Define a condition that checks if the player is holding a specific item
    $condition = function(Player $player): bool {
      return $player->getInventory()->getItemInHand()->getId() === Item::DIAMOND_SWORD;
    };
  
    // Define the action to be executed if the condition is met
    $action = function(Player $player): void {
      $player->sendMessage("You are holding a diamond sword!");
    };
  
    // Create a new PerPlayerTrigger
    $perPlayerTrigger = new PerPlayerTrigger($condition, $action);
  ```
- **`GlobalTrigger:`** To create a trigger that performs an action globally when a specific condition is met, see more below:
  ```php 
    use imperazim\components\trigger\GlobalTrigger;
    
    // Define a condition that checks if a specific game event has occurred
    $condition = function(): bool {
      return GameState::isNightTime();
    };
    
    // Define the action to be executed if the condition is met
    $action = function(): void {
      Server::getInstance()->broadcastMessage("Night has fallen!");
    };
    
    // Create a new GlobalTrigger
    $globalTrigger = new GlobalTrigger($condition, $action);
  ```
- **`TriggerManager:`**
  - Registers a new **Trigger** (either **PerPlayer** or **Global**) to be checked at a given interval.</li>
  - The trigger is automatically added to a static list for centralized management and scheduled execution:
  ```php 
    use imperazim\components\trigger\TriggerManager;
    
    // Add the trigger to the Trigger Thread
    TriggerManager::addTrigger($globalTrigger || $perPlayerTrigger);
  ```

### `imperazim\components\cache`
**The Cache** class is responsible for caching data within a system. It allows you to store, retrieve, and invalidate data temporarily or permanently, as well as provide statistics about the cache.
- **Storing and Retrieving Cached Data:** To store data in the cache and retrieve it later:
  ```php 
    use imperazim\components\cache\Cache;

    // Store data in the cache with a key and a time to live (TTL) of 60 seconds
    Cache::put('player_points', 100, 60);
    
    // Retrieve the cached data
    $points = Cache::get('player_points');
    if ($points !== null) {
      echo "Player points: " . $points;
    } else {
      echo "Cache expired or not found.";
    }
  ```
- **Caching Data Without Expiration:** If you want to store data in the cache indefinitely without setting a TTL:
  ```php 
    use imperazim\components\cache\Cache;

    // Store data without expiration
    Cache::put('server_settings', ['difficulty' => 'hard', 'max_players' => 50]);
    
    // Retrieve the cached data
    $settings = Cache::get('server_settings');
    if ($settings !== null) {
      echo "Server settings: " . json_encode($settings);
    }
  ```