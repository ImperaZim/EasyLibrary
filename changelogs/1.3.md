**For PocketMine-MP 5.18.1**

# 1.3.0
---

**Released #st September 2024**

**EasyLibrary v1.3.0** is a major feature update to EasyLibrary, including support for PocketMine-MP 5.18.1 plugins, bringing a large list of features and improvements over the previous version.

It is not compatible with plugins written for version 1.2.0 or lower, and plugins may require code changes to work with it.

As this changelog is quite large, its accuracy and completeness cannot be guaranteed. Make sure you're looking at the [latest revision](https://github.com/ImperaZim/EasyLibrary/blob/development/changelogs/1.3.md), as it may be amended after release.

* [Gameplay](#gameplay)
  + [Avoid Suffocation](#avoid-suffocation)
* [Components](#components)
  + [Changes](#changes)
    + [Plugin](#plugin)
      - [PluginComponent](#plugincomponent)
  + [New Features](#new-features)
    + [Plugin](#plugin)
      - [PluginCdnResourcePackTrait](#plugincdnresourcepacktrait)
    + [Trigger](#trigger)
      - [PerPlayerTrigger](#perplayertrigger)
      - [GlobalTrigger](#globaltrigger)
    +  [Cache](#cache)
  
---

## Gameplay
### Avoid Suffocation
- You will no longer clip through the ground when teleporting to certaComponents

## Components 
### Changes
#### Plugin
#### `PluginComponent`

Starting from version 1.3, you no longer need to explicitly define the `setPlugin(Plugin $plugin)` method in the `init()` function of your component. The framework’s initializer now automatically assigns the plugin instance to the component, making the code more streamlined.

For example, previously, you might have done this manually:

```php
public static function init(PluginToolkit $plugin): array {
  self::setPlugin($plugin);
}
```

As of version 1.3, this is no longer required. You can now access the plugin directly using `YourComponent::getPlugin()` without needing to manually assign it within the `init()` method.

> [!IMPORTANT] 
> If you still have existing code that explicitly calls `setPlugin()`, you do **not** need to remove it. The system will check whether a plugin instance is already assigned. If a plugin is already defined, the framework will respect the existing assignment and not overwrite it. However, if no plugin is defined, the initializer will automatically assign the plugin.

This ensures backward compatibility with older code, so there’s no need to modify or refactor components where `setPlugin()` is still being called.
### New Features 
#### Trigger 
> The Trigger class represents a system of task-based triggers, where a condition is checked and if that condition is met, an action is executed. It is used to manage dynamic tasks in the system, triggering scripts when a certain condition is met.

- <a id="perplayertrigger"></a>**PerPlayerTrigger:** To create a trigger that performs an action for each player when a specific condition is met, see below:

  ```php 
    use imperazim\components\trigger\PerPlayerTrigger;
  
    // Define a condition that checks if the player is holding a specific item
    $condition = function(Player $player): bool {
      return $player->getInventory()->getItemInHand()->getId() === Item::DIAMOND_SWORD;
    };
  
    // Define the action to be executed if the condition is met
    $action = function(Player $player): void {
      $player->sendMessage("You are holding a diamond sword!");
    };
  
    // Create a new PerPlayerTrigger
    $perPlayerTrigger = new PerPlayerTrigger($condition, $action);
  ```
- <a id="globaltrigger"></a>**GlobalTrigger:** To create a trigger that performs an action globally when a specific condition is met, see more below:

  ```php 
    use imperazim\components\trigger\GlobalTrigger;
    
    // Define a condition that checks if a specific game event has occurred
    $condition = function(): bool {
      return GameState::isNightTime();
    };
    
    // Define the action to be executed if the condition is met
    $action = function(): void {
      Server::getInstance()->broadcastMessage("Night has fallen!");
    };
    
    // Create a new GlobalTrigger
    $globalTrigger = new GlobalTrigger($condition, $action);
  ```
- **TriggerManager:** 
  - Registers a new `Trigger` (either `PerPlayer` or `Global`) to be checked at a given interval.
  - The trigger is automatically added to a static list for centralized management and scheduled execution:

      ```php 
        use imperazim\components\trigger\TriggerManager;
        
        // Add the trigger to the Trigger Thread
        TriggerManager::addTrigger($globalTrigger || $perPlayerTrigger);
      ```
#### Cache 
> The `Cache` class is responsible for caching data within a system. It allows you to store, retrieve, and invalidate data temporarily or permanently, as well as provide statistics about the cache.
- **Storing and Retrieving Cached Data:** To store data in the cache and retrieve it later:

  ```php 
    use imperazim\components\cache\Cache;

    // Store data in the cache with a key and a time to live (TTL) of 60 seconds
    Cache::put('player_points', 100, 60);
    
    // Retrieve the cached data
    $points = Cache::get('player_points');
    if ($points !== null) {
      echo "Player points: " . $points;
    } else {
      echo "Cache expired or not found.";
    }
  ```
- **Caching Data Without Expiration:** If you want to store data in the cache indefinitely without setting a TTL:

  ```php 
    use imperazim\components\cache\Cache;

    // Store data without expiration
    Cache::put('server_settings', ['difficulty' => 'hard', 'max_players' => 50]);
    
    // Retrieve the cached data
    $settings = Cache::get('server_settings');
    if ($settings !== null) {
      echo "Server settings: " . json_encode($settings);
    }
  ```
# Utils